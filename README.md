# V8 Internals - A Security Nerd's Prespective

## Abstract
Open source softwares are inherently trusted by users & 
developers. This is especially true for modern web-browsers 
like Chromium, which touches user's personal data very 
frequently. However, browsers are hard to secure, inherently 
complex machines. Most browsers have their own memory 
management and system software, almost like an operating 
system. In this study we present internals of V8 engine, which 
is the Javascript engine powering Chromium web-browser. We 
analyze the major components in depth and then dive into 
taint-tracking implementation / previous vulnerabilities in 
order to explore the current landscape in a systematic way. 
Our intent is to provide a one stop location to understand the 
core V8 internals, while looking for opportunities for 
improvement from a security perspective. 

## Introduction
The twenty first century can be thought of as a century of 
open source software. From industrial systems all the way to 
your microwave might be running a version of an opensource 
software. While we use a lost of open source software 
indirectly, web browsers is a unique kind of software. From an 
application perspective, it allows us to interact with the 
world and do anything from sending an email, all the way to 
stream videos and games via cloud. On the software end, 
Chromium does it's own memory management, has builtin 
interpreter and compiler which compiles code generated by an 
internal CSA code. Chromium has characteristics of an 
application software and system software all at once.

We trust our Web browser all of our personal data. But where 
does our trust come from? While it is open source, it is 
important that some formal verification keeps going into the 
system<sup>[1]</sup>. Google does pretty good job 
regarding this with their bug bounty system<sup>[2]</sup>. 
However, the Chromium's codebase changes a lot all the 
time and hence it's very important that we keep the bar low 
enough so that new developers find it easy to get started with 
Chromium and improve on it's security.

The goal of this study is to make such contributions to a 
component of Chromium, its Javascript engine V8. 
V8 engine is also used in NodeJS, to run javscript code on 
server side and other standlone application frameworks like 
electron. This causes security bugs in V8 to have a much 
larger blast radius when something does go wrong. 

V8 has a steep learning curve for anyone who has little 
experience working on chromium codebase. While documentation 
exists for developers, there is little documentation for 
anyone looking from a security perspective. There has been 
some notable work by Sergei Glazunov<sup>[9]</sup>, Stephen 
Röttger<sup>[3]</sup>, Jeremy Fetiveau<sup>[4]</sup>, Samuel 
Groß<sup>[5]</sup>, and Javier Jimenez<sup>[6][7]</sup>, who 
all have published blog posts on their findings. There have 
also been several fuzzing projects<sup>[8]</sup> introduced, 
with enough documentation so that anyone can use those 
tools. However, these resources do not give someone who is 
new to the field enough information to begin their research, 
and while fuzzing can cover more code in a faster time, it 
is no replacement for code review and documentation on how 
the systems internally work.

We will start by exploiring some [background](#background) 
work which is required to understand the V8 engine better. 
This will mainly consist of some newer C++11/14 features 
which chromium codebase makes us of, and a tour of V8. 
Next, we shall exlopre the internals in a sequential 
and easy to follow manner, which would give you a tour of 
the componments inside V8.

## Background

V8 and Chromium codebase are written using the C++14 standard 
at the time of writing. V8 exploits a lot of newer C++14 features
like `const-expr`, `auto` among others to write code in a very 
extensible way. Ideas relating to this have been covered in the 
[C++ Intro](docs/cpp_intro.md) article.

V8 is an Javscript optimizing compiler. It has an inbuilt Interpreter 
and a optimizing compiler, which can collect type information while 
Javascript is running and produce more specialized and efficient code. 
The document [high level tour](docs/high_level_architecture.md) goes over 
the major components inside V8 to give you a summary of the components 
inside V8.

The remaining of the report is divided into several sections. [Internals](#internals) 
provides a view of the major components in V8 without any asssumed 
prior knowledge. Following that, [Experiements](#experiments) discusses 
various experiments and hands-on activity we performed in order to 
understand one or more components in greater depth. Lastly, we present 
a analysis of aversion of V8 which was modified to implement 
taint-tracking `String` objects. 

## Internals

In this section we will start looking into various major components
inside V8 engine.

### V8 Codebase
In [V8 codebase exploration](docs/V8_code_base.md) article, we go over 
the location where the codebase for the components we learnt about in the 
[high level tour](/docs/high_level_architecture.md) are located. Some new
components like `codegen` and `execution` are also introduced, which act 
as entinties which makes V9 work together well.

### Turbofan

In [Optimizing Compiler - Turbofan](docs/Turbofan.md) article, we explore the 
Turbofan - "The optimizing compiler inside V8". This article goes into good depth 
about how the optimizing compiler inside V8 works and the ideas about 
`Sea of Nodes`, `Typing` are covered here along since `turbolizer` which is a tool 
that can be use to analyze Javascript code which is getting optimized by Turbofan.

### Javscript Variables' Representation in V8

In [Javascript Objects in memeory](/docs/JavaScript%20Variables'%20Representation%20in%20Memory.md)
article, we go over how V8's memory management and object creation 
backend functions to create Javascript objects. Key ideas like how Javascript functions look like in C++ memory, `Pointer Compression`,
`Shapes & Hidden Classes`, `inline caches` are discussed here. This 
information will prove to be helpful in understanding how any basic 
Javascript object (like `String`) is implemented in the V8 engine.

### CSA, Torque & Builtins
In [Builtins](docs/builtins_basics.md) article, we explore how the 
ECMAScript standard is implemented in V8 (builtins). Since V8 needs to produced byte
code, which is platform dependent, a lot of architecture specific tweaks
are possible to boost performance. Rather than handcrafting builtins for
each of the many platform, V8 built a higher level assumbler, which 
allows us to write the builtins in near assembly and the assembles it
down to architecture optimized version.

## Experiments
While in section [Internals](#internals) we read through in great details
about the major components of V8, nothing really beats some hands - on 
experience with playing around with the components.

### Embedding V8 - Tracing Controlflow
In this two part series, we explore how the idea of Embedding V8 works.
In the [V8 exploration - I](docs/v8_exploration_I.md), we look at the basics of embedding V8 inside another program. This is the teachnique which is used by `Chromium`, `NodeJS` and others in order to interface
with V8 invisibly.
In [V8 exploration - II](docs/v8_exploration_II.md), we try executing a simple line of `Javascript` code and trace it through the V8 codebase. This helps us to get and inituitive understanding of the locations which are hit by the V8 codebase when the functions intresting to us are called. We also discuss how to effectively use GDB while debugging V8.

### Javascript Engine Exploitation Primitive
In the [V8 Exploitation Primitives](/docs/JavaScript%20Engine%20Exploitation%20Primitives.md)
article, we shift gears and talk about the exploitation primitives which 
have existed in the V8 engine subspace. Here we discuss the primitive 
that we want to gain through a bug, allowing us to gain different kinds
of privileges. This is done through exploration of various examples.

## Taint - Tracking in V8
<---PANDU--TODO---->

## References
[1] M. Curphey and D. A. Wheeler, “Improving Trust and Security in Open Source Projects,” p. 27.

[2] ‘Chrome Rewards – Application Security – Google’. https://www.google.com/about/appsecurity/chrome-rewards/index.html (accessed Dec. 03, 2020).


[3] Ben, ‘Project Zero: Trashing the Flow of Data’, Project Zero, May 10, 2019. https://googleprojectzero.blogspot.com/2019/05/trashing-flow-of-data.html (accessed Aug. 30, 2020).

[4] ‘Diary of a reverse-engineer - Jeremy “__x86” Fetiveau’. https://doar-e.github.io/author/jeremy-__x86-fetiveau.html (accessed Aug. 30, 2020).

[5] Tim, ‘Project Zero: JSC Exploits’, Project Zero, Aug. 29, 2019. https://googleprojectzero.blogspot.com/2019/08/jsc-exploits.html (accessed Aug. 30, 2020).

[6] ‘SensePost | Intro to chrome’s v8 from an exploit development angle’. https://sensepost.com/blog/2020/intro-to-chromes-v8-from-an-exploit-development-angle/ (accessed Aug. 25, 2020).

[7] ‘SensePost | The hunt for chromium issue 1072171’. https://sensepost.com/blog/2020/the-hunt-for-chromium-issue-1072171/ (accessed Aug. 30, 2020).

[8] ‘v8/test/fuzzer’, GitHub. https://github.com/v8/v8/tree/master/test/fuzzer (accessed Aug. 30, 2020).

[9] A Tale of Two Pwnies (Part 1)’, Chromium Blog. https://blog.chromium.org/2012/05/tale-of-two-pwnies-part-1.html (accessed Aug. 30, 2020).